# 传输层TCP和UDP协议

## TCP
**TCP是面向连接的，基于TCP发送的基础是端对端的连接。TCP具有可靠性，保证数据顺序，采用字节流模式，包含固定20字节首部。由于是端对端进行传输，所以TCP不能发送广播消息**

### 三次握手建立连接

#### 第一次
建立连接的过程是客户端主动发起的，服务器被动打开，此时服务器创建的TCB正在监听某个端口。第一次握手的过程是用户向服务器发送一个SYN报文段，但是不能TCP协议中规定该SYN报文段不能携带数据，并且客户端需要初始化一个序列码seq；此时客户端进入到了SYN-SENT状态。

#### 第二次
当客户端进入到SYN-SEND状态的时候，如果服务器接收连接，会向客户端发出确认报文，报文中包含一个ACK = 1，SYN = 1；也需要为自己初始化一个seq序列码，还有一个应答码ack = 第一次seq + 1，表示我已经我收到了，此时服务器进入到SYN-RECE状态。

#### 第三次
当服务端同意连接并且客户端收到服务器发送的确认报文的时候，客户端也会向服务器发送确认，这个时候的ack = 第二次服务器的seq+1，序列码就是第二次服务器seq+1；此时TCP建立连接完成，双方都进入到established状态进行信息交互。

**第三次客户端发送应答码的必要性在于，如果客户端第一次发送的请求连接报文阻塞到了网络中，由于久久不能得到服务器回复，客户端会再次发送一次请求报文，并且第二次发送的报文成功被服务器收到，服务器答应了客户端请求，这个时候连接建立，但是第一条请求报文还阻塞在网络链路中。如果客户端和服务器已经完成了数据传输关闭了链接，而这个时候第一次阻塞的报文因为链路的恢复又达到了服务器端，就会再次进行链接，从而消耗不必要的资源也会带来安全性隐患。有了第三次握手，客户端就不会发送第三次确认信息，也就不会重新建立连接了。**

### 四次挥手关闭连接

#### 第一次
当客户端和服务器完成了数据传输之后，客户端首先会发送一个连接终止报文，报文头中包含FIN = 1，seq就基于前面最后发送的数据+1；从这个时候开始客户端不会在向服务器发送连接终止之外的数据。此时客户端进入FIN-WATI-1状态。等待服务器的应答报文。

#### 第二次
服务器收到了来自客户端的FIN报文，会发送一个应答报文ACK=1，ack = seq + 1；并且同样也会带上自己的序列号，此时服务器就进入了CLOSE-WAIT状态。TCP连接此时出于半关闭状态，因为很有可能客户端数据发送完了，但是服务器还有数据需要发送到客户端，这个时候客户端仍然会接受，所以这个状态可能要持续一段时间。
客户端收到来自服务器的确认报文之后，进入FIN-WATI-2状态，等待服务器发送的连接释放报文。而在此期间服务器可能还会向客户端发送数据。

#### 第三次
当服务器把最后需要的数据传输完毕时候，就会再次发送终止确认报文FIN = 1，ACK = 1，但是此时的seq可能就会变，发送完毕之后服务器就会进入LAST-ACK状态。

#### 第四次
客户端收到服务器的连接释放报文，还必须发出确认报文ACK=1，同样包含seq和ack，此时客户端就进入了TIME-WAIT状态。这个时候的TCP仍然没有释放，而是进入到了2MSL（maximum segment lifetime），当应用程序撤销掉TCB之后才会关闭。而服务器只要收到了客户端的确认报文就会立即进入到CLOSED状态。所以服务器要比客户端早一点关闭。

**MSL状态的意义**
- 客户端发送的确认报文，也就是最后一次确认关闭链接的报文有可能也被阻塞到网络中，但是服务器长时间不能收到，服务器就觉得是自己发送的报文客户端没接收到，所以服务器会再次发送请求终止的报文，这个时候客户端是没有关闭的，所以会继续发送终止确认报文，同时又重启MSL计时器。    

-  防止客户端发送的请求报文报文阻塞到了网络链路中又被服务器接收，在这个2MSL时间内客户端让那些无效报文段从网络链路中消失，这样就不会有旧的报文连接发送到服务器端。

**为什么握手三次挥手四次**  
握手的过程中可以说没有信息数据的传输，是一个相互应答的过程，所以服务器会将SYN ACK一起发送，但是客户端发送终止连接的时候，很有可能服务器还有一些数据没有发送完，所以服务器只是先答应，但是需要等待数据传输完毕之后再发送FIN报文，ACK和FIN是分开的，因此多了一次。
