# JVM
JVM在运行时开辟内存的区域主要分为两大类，一类是线程共享的，JAVA堆和方法区；一类是线程私有的，VM栈，程序计数器和本地方法栈。

## 线程私有
线程私有包含虚拟栈和本地方法栈以及程序计数器。

### 程序计数器
程序计数器是最小的内存栈，JVM在解释字节码的时候就是按照程序计数器指向的下一条执行的，程序计数器需要处理跳转，分支，循环，异常处理等；**程序计数器是唯一不会抛出OutOfMemoryError的内存空间**，他伴随着线程的创建而创建，随着线程的消亡而消亡；

### 虚拟机栈
虚拟机栈中主要执行类的方法。每个方法别执行的时候，都会创建一个栈帧，栈帧中存放着该方法中包含的局部变量，操作数，动态链接（调用别的方法），方法出口等。每个方法的执行到执行完毕就是该方法对应的栈帧从入栈到出栈的过程。生命周期与线程相同。
+ **OutOfMemoryError** 虚拟机栈不是固定大小的，每当栈空间不足的时候JVM都会为虚拟机栈申请新的内存空间，当无法申请失败的时候就会抛出该异常；
+ **StackOverflowError** 虚拟机中执行方法规定了方法的层级，比如递归，嵌套至多有多少层，如果程序执行的方法超过了这个层数就会抛出该异常 ；

### 本地方法区
本地方法区的作用于虚拟栈相同，只不过虚拟机栈中执行的是Java方法，也就是字节码。而本地方法区执行的是Native方法。

## 线程共享
线程共享包含着方法区和Java Heap(堆)

### 方法区
方法区中主要存放着类的静态变量和常量值，和已经被虚拟机加载的类信息（编译后生成的字节码文件）

#### 运行时常量池
在JDK1.7之前的版本中，运行时常量池是存在于方法区的。但是在JDK1.8之后就在Java堆中为它开辟了一块空间。他存放的就是各种字面量和符号引用。

### Java堆
Java堆是为Java对象实例分配空间的地方，是JVM内存管理中最大的一块区域，Java堆唯一的目的就是为存放对象实例，程序中几乎所有的对象实例和数组都在这里被分配，因此Java堆也被称为GC区。GC主要的垃圾回收都是在Java堆中发生的。Java垃圾回收有以下几种通常的算法：

#### 引用计数法
引用计数法顾名思义就是对对象的引用进行计数。JVM跟踪所有对象，在java堆的每个对象头中维护一个counter计数器，每当new一个对象的时候，置该对象的引用计数为1。如果该对象增加了一个对象引用与之相连，则counter自增，如果一个引用失效，比如置空，该对象的couter自减。每当发生GC的时候那些计数为0的对象就要被回收。但是java并不采用该垃圾回收算法，因为存在很多缺陷，最致命的一点就是A持有B的引用，B也持有A的引用的时候，相当于进入了死锁状态，AB中不可能都被回收。

#### 标记-清除算法
当Java堆内存不够的时候，后台就会启动GC线程，GC线程会停止当前程序运行，对GC ROOT开始的对象进行检索，每检索到一个可达对象就将其标记，遍历完所有的对象之后，那些未被标记也就是不可达的对象将会被全部清除。清除算法耗时比较大，而且要中断应用程序的执行，用于体验不佳，而且会产生大量的内存碎片。

#### 标记-整理算法
标记整理算法是对标记清除算法的改进，用于修正标记清楚算法造成的内存碎片问题。当标记完成让移动所有可达的对象并且按照内存地址的顺序排列，而后清除掉那些在边界之外的对象

#### copy算法
复制算法的原理是，JVM首先将堆分为对象区和空闲区。每当对象区内存不足的时候，GC就将对象区的活动对象复制一份到空闲区中，然后将空闲区作为新的对象区，将之前的对象区内存全部回收，作为新的空闲区。

## 新生代老年代和永久代（永久代已经被元数据区替换）
Java堆一般被分为三大部分。新生代，老年代，和永久代。

### 新生代
新生代中继续又被分为Eden区，SurvivorFrom和SurvivorTo区域，新生的对象会被存放在Eden区，如果新生的对象很大就会直接被放到老年代，当Eden区域不够存放新生的对象的时候，就会触发一次MinorGC，MinorGC采用的是复制算法，SurvivorFrom和Eden就相当于对象区，SurvivorTo就相当于空闲区，每当发生一次MinorGC后SurvivorTo和SurvivorFrom互换，同时把所有对象的年龄+1，如果某些对象年龄到了老年的标准或者SurvivorTo内存不够的时候，MinorGC就会把对象就移动到老年代。

### 老年代
老年代中存放的一半是生存期较长的对象，所以相对稳定，MajorGC不会频繁发生，一半是新晋对象进入到老年代导致空间不足的时候才会发生一次MajorGC，MajorGC采用标记清除算法。当老年内存不够用就会抛出OutOfMemoryError异常；

### 永久代
永久代和新生代和老年代不同，永久代存放的是JVM已经加载的类数据，类被加载的时候就会被放入永久代，永久代不会在程序执行的时候发生GC，这就意味着如果随着时间的推移，加载的类的信息会越来越多，最终导致OOM异常。所以在jdk1.8中，永久代被元数据区取代。元数据区跟永久代功能类似，只不过他是在本地内存中开辟空间而不是java虚拟机。因此默认情况下元数据区内存的大小和格式只受到本机限制。
