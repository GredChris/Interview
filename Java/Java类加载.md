# Java类加载
类是拥有共同属性的对象的抽象概念。JVM没有明确规定一个类应该在什么时候被加载，但是当new一个该类对象，或者putStatic设置该类的静态属性，或者getStatic获取该类的静态属性，或者invokeStatic调用该类的静态方法的时候，JVM首先会检测该类是否已经被加载，如果没有，则加载该类。类加载器的任务就是根据该类的名称（包括包命）读取该类的字节码文件（也就是.class文件）到JVM中，然后转换成该类对应的一个Java.lang.Class对象实例。
类在被加载到卸载的过程中主要包括加载(loading)，验证(verification)，准备(preparation)，解析(resolution)，使用(using)和卸载（uploading）。其中验证，准备和解析被称为链接过程。

## 加载(Loading)
加载过程就是类加载器根据对应的类全限定名读取该类的字节码文件(.class)文件加载到JVM中，并存储在方法区内存中，然后把它转换为一个java.lang.Class对象的实例。 在整个程序运行的过程中该Class对象就会作为该类的方法和数据访问接口。

## 链接（Linking）
链接阶段要做的是将加载到JVM中的二进制字节流的类数据信息合并到JVM的运行时状态中，经由验证、准备和解析三个阶段。

### 验证(Verification)
验证类数据信息是否符合JVM规范，是否是一个有效的字节码文件，验证内容涵盖了类数据信息的格式验证、语义分析、操作验证等。
+ **格式验证** ：验证是否符合class文件规范
+ **语义验证**：检查一个被标记为final的类型是否包含子类；检查一个类中的final方法视频被子类进行重写；确保父类和子类之间没有不兼容的一些方法声明（比如方法签名相同，但方法的返回值不同）
+ **操作验证**：在操作数栈中的数据必须进行正确的操作，对常量池中的各种符号引用执行验证（通常在解析阶段执行，检查是否通过富豪引用中描述的全限定名定位到指定类型上，以及类成员信息的访问修饰符是否允许访问等）

### 准备(Preparation)
为类中的所有静态变量分配内存空间，并为其设置一个初始值（由于还没有产生对象，实例变量不在此操作范围内）。被final修饰的静态变量，会直接赋予原值；类字段的字段属性表中存在ConstantValue属性，则在准备阶段，其值就是ConstantValue的值（int 0, float 0.0等）；

### 解析(Resolution)
将常量池中的符号引用转为直接引用（得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法），这个可以在初始化之后再执行。可以认为是一些静态绑定的会被解析，动态绑定则只会在运行是进行解析；静态绑定包括一些final方法(不可以重写),static方法(只会属于当前类)，构造器(不会被重写)

### 初始化(Initiazation)
将一个类中所有被static关键字标识的代码统一执行一遍，如果执行的是静态变量，那么就会使用用户指定的值覆盖之前在准备阶段设置的初始值；如果执行的是static代码块，那么在初始化阶段，JVM就会执行static代码块中定义的所有操作。
所有类变量初始化语句和静态代码块都会在编译时被前端编译器放在收集器里头，存放到一个特殊的方法中，这个方法就是<clinit>方法，即类/接口初始化方法。该方法的作用就是初始化一个中的变量，使用用户指定的值覆盖之前在准备阶段里设定的初始值。任何invoke之类的字节码都无法调用<clinit>方法，因为该方法只能在类加载的过程中由JVM调用。
如果父类还没有被初始化，那么优先对父类初始化，但在<clinit>方法内部不会显示调用父类的<clinit>方法，由JVM负责保证一个类的<clinit>方法执行之前，它的父类<clinit>方法已经被执行。
JVM必须确保一个类在初始化的过程中，如果是多线程需要同时初始化它，仅仅只能允许其中一个线程对其执行初始化操作，其余线程必须等待，只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程。
